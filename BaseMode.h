/* BaseMode.h - Multi-scale competency bootstrap for C and Python */

#ifndef BASEMODE_H
#define BASEMODE_H

#include <stdint.h>
#include <stddef.h>

/* ============================================================================
 * Part 1: The Prepass Quine (VJ's Trick)
 * ============================================================================
 * 
 * This header is GENERATED by scanning BaseMode.c for:
 *   - All bm_* function signatures (forward declarations)
 *   - All struct definitions (type boundaries)
 * 
 * The prepass script is ITSELF a morphism:
 *   Input: BaseMode.c (t=0)
 *   Output: BaseMode.h (t=0+1, first differentiation)
 * 
 * This creates a BOUNDARY EVENT: the system observes its own structure
 * and generates the scaffolding needed for its own execution.
 */

/* ============================================================================
 * Part 2: Morphological Primitives (t=0+1)
 * ============================================================================ */

/* The BaseMode: A quantized differentiation event */
typedef struct BaseMode BaseMode;

/* Morphological state: The "what am I?" question */
typedef enum {
    MODE_GENESIS = 0,      /* t=0: Undifferentiated potential */
    MODE_PREFIXED = 1,     /* t=0+1: First observation (VJ's prepass) */
    MODE_LINEARIZED = 2,   /* t=0+2: C3 ordering established */
    MODE_EVOLVED = 3,      /* t=0+3: δ∘L applied (collapse + evolution) */
    MODE_MATERIALIZED = 4  /* t=0+4: Arena instantiated */
} ModeState;

/* Morphism: A dependency relation (category-theoretic arrow) */
typedef struct {
    const char* name;      /* Identity */
    const char** deps;     /* Prerequisites (other morphism names) */
    size_t dep_count;      /* Number of dependencies */
    void (*action)(void*); /* What this morphism DOES (first-class function!) */
} Morphism;

/* BaseMode: The differentiation primitive */
struct BaseMode {
    /* Identity */
    const char* lineage;   /* Semantic version: "bm_0", "bm_0_1", etc. */
    
    /* State */
    ModeState state;       /* Current differentiation level */
    uint64_t generation;   /* t=0+n where n >= 1 */
    
    /* Morphological structure */
    Morphism* morphisms;   /* Array of morphisms (the "what can I become?") */
    size_t morph_count;
    
    /* Evolution sequence (linearized timeline) */
    const char** timeline; /* C3-linearized ordering */
    size_t timeline_len;
    
    /* Memory arena (shared substrate) */
    void* arena_ptr;       /* NULL until materialized */
    size_t arena_size;
};

/* ============================================================================
 * Part 3: Multi-Scale Competency Operations
 * ============================================================================
 * 
 * These functions work at BOTH scales:
 *   - C scale: Direct memory manipulation (thermodynamically honest)
 *   - Python scale: CPython API calls (convenient, but expensive)
 */

/* Genesis: Create a BaseMode at t=0 */
BaseMode* bm_genesis(const char* lineage);

/* Observe: Apply VJ's prepass (t=0 → t=0+1) */
int bm_observe(BaseMode* mode);

/* Linearize: Compute C3 ordering (t=0+1 → t=0+2) */
int bm_linearize(BaseMode* mode);

/* Evolve: Apply δ∘L (t=0+2 → t=0+3) */
int bm_evolve(BaseMode* mode);

/* Materialize: Instantiate arena (t=0+3 → t=0+4) */
int bm_materialize(BaseMode* mode, size_t arena_size);

/* Query: What is my type? (The busy-line fallback) */
const char* bm_typeof(BaseMode* mode);

/* Cleanup */
void bm_destroy(BaseMode* mode);

/* ============================================================================
 * Part 4: The Prepass Script (Quineic Bootstrap)
 * ============================================================================
 * 
 * This is the EXTERNAL observer that generates this header.
 * It's written in Python (for convenience) but could be C (for purity).
 */

#ifdef BASEMODE_IMPLEMENTATION

/* Implementation follows... (in BaseMode.c) */

#endif /* BASEMODE_IMPLEMENTATION */

#endif /* BASEMODE_H */
